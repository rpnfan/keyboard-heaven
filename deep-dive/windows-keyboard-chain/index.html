<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding Windows Keyboard Input: The Complete Chain | Keyboard Heaven</title><meta name=keywords content><meta name=description content="Windows keyboard input travels through five transformation layers: HID → Scancode → Virtual Key → Layout → Character. This article explains each layer, why they exist, and why understanding them is crucial when you use or want to create custom keyboard layouts."><meta name=author content><link rel=canonical href=https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/><link crossorigin=anonymous href=/keyboard-heaven/assets/css/stylesheet.126ebacd42cca6ed4a15a327717f23082469d45c1055c4f457f3370621504a7f.css integrity="sha256-Em66zULMpu1KFaMncX8jCCRp1FwQVcT0V/M3BiFQSn8=" rel="preload stylesheet" as=style><link rel=icon href=https://rpnfan.github.io/keyboard-heaven/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rpnfan.github.io/keyboard-heaven/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rpnfan.github.io/keyboard-heaven/favicon-32x32.png><link rel=apple-touch-icon href=https://rpnfan.github.io/keyboard-heaven/apple-touch-icon.png><link rel=mask-icon href=https://rpnfan.github.io/keyboard-heaven/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/"><meta property="og:site_name" content="Keyboard Heaven"><meta property="og:title" content="Understanding Windows Keyboard Input: The Complete Chain"><meta property="og:description" content="Windows keyboard input travels through five transformation layers: HID → Scancode → Virtual Key → Layout → Character. This article explains each layer, why they exist, and why understanding them is crucial when you use or want to create custom keyboard layouts."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="deep-dive"><meta property="article:published_time" content="2026-01-06T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-11T18:12:10+01:00"><meta property="og:image" content="https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain.png"><meta name=twitter:title content="Understanding Windows Keyboard Input: The Complete Chain"><meta name=twitter:description content="Windows keyboard input travels through five transformation layers: HID → Scancode → Virtual Key → Layout → Character. This article explains each layer, why they exist, and why understanding them is crucial when you use or want to create custom keyboard layouts."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Keyboard Analyzers and More","item":"https://rpnfan.github.io/keyboard-heaven/deep-dive/"},{"@type":"ListItem","position":2,"name":"Understanding Windows Keyboard Input: The Complete Chain","item":"https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding Windows Keyboard Input: The Complete Chain","name":"Understanding Windows Keyboard Input: The Complete Chain","description":"Windows keyboard input travels through five transformation layers: HID → Scancode → Virtual Key → Layout → Character. This article explains each layer, why they exist, and why understanding them is crucial when you use or want to create custom keyboard layouts.","keywords":[],"articleBody":"Introduction When you press a key on your Windows keyboard, the input doesn’t immediately appear on your screen. Instead, it travels through multiple transformation layers — a chain that converts raw hardware signals into text, hotkeys, and game commands. Understanding this chain is essential for anyone working with custom keyboards, keyboard layouts, or applications that handle input.\nThe complete Windows keyboard input chain looks like this:\nHID Usage ID → Windows Scancode → Virtual Key Code (VK) → Windows Keyboard Layout → Character Output / Application Input But the story is more complex than it appears. Not all applications use every step, and choosing which step to use has profound consequences for compatibility and functionality.\nTerminology: Three Distinct Concepts Before diving into the chain, it’s crucial to clarify three concepts that are often confused because they’re all called “keyboard layout” in casual speech:\n1. Physical Key Layout / Position The physical arrangement of keys on the keyboard hardware.\nExamples: ANSI 104-key (standard US), ISO 105-key (European), split columnar staggered ergonomic keyboards (Kinesis Advantage, Lily58 …)\n2. Windows Keyboard Layout The input layout selected in Windows Settings under Language \u0026 Region → Keyboard, determining character mapping and Virtual Key assignments.\nExamples: US English (QWERTY), French (AZERTY), German (QWERTZ), Dvorak, Colemak\n3. Software Remapping Layer Custom key transformations applied via software tools (such as Kanata, AutoHotkey) that intercept input after the Windows keyboard layout processes it.\nExamples: Kanata profiles (e.g. for anymak:END, Graphite), AutoHotkey scripts\nNote: QMK or ZMK firmware is different — it operates at the HID level, replacing the standard HID input from a keyboard, not layering on top of the Windows keyboard layout.\nThe Windows Keyboard Input Chain Step 1: HID Usage ID (The Transport Layer) Modern USB keyboards speak the language of HID (Human Interface Device) standards defined by the USB Implementers Forum. When you press the “A” key, your keyboard firmware sends a HID usage ID — specifically 0x04 from the HID Keyboard/Keypad page (usage page 0x07) — over the USB bus.\nThis is why keyboard firmware like QMK uses keycodes like KC_A: these are symbolic names for HID usage IDs. The HID standard is universal across operating systems, making it the common ground between your keyboard hardware and any operating system.\nEach operating system then translates that HID usage according to its own architecture. Windows converts HID to scancodes, macOS has its own mapping, Linux has yet another — but they all start from the same HID usage ID.\nStep 2: Windows Scancode (The Position Identifier) The Windows HID driver (kbdhid.sys) receives the HID usage ID and converts it into a Windows keyboard scancode — essentially a legacy PS/2-era code that identifies the physical key location on the keyboard. Scancodes are truly form-factor-independent and Windows-keyboard-layout-independent; they represent raw physical positions.[1][2]\nFor example, on a standard ANSI keyboard:\nHID usage 0x04 (A key) → Windows scancode 0x1E HID usage 0x05 (B key) → Windows scancode 0x30 Critical point: Scancode 0x1E always refers to the same physical key position on an ANSI keyboard, the one labeled “A” in the US layout. Regardless of which Windows keyboard layout you activate, scancode 0x1E always corresponds to that same physical location.\nWhy scancodes do .sexist: Windows maintains decades of backward compatibility with PS/2 keyboard code. Scancodes provide a stable reference to physical hardware positions that doesn’t change when the user switches Windows keyboard layouts.\nStep 3 \u0026 4: Virtual Key Code and Windows Keyboard Layout DLL (Linked Concepts) The scancode is then passed to the active Windows keyboard layout, which is provided as a DLL file (e.g., kbdus.dll for US, kbdfr.dll or the updated kbdfrna.dll for French). This DLL performs two linked transformations:\nFirst: Scancode-to-VK mapping\nThe DLL maps the scancode to a Virtual Key (VK) code. This mapping depends entirely on which Windows keyboard layout is active.\nSame physical key position (scancode 0x1E on ANSI keyboard): US English (QWERTY) layout active: Scancode 0x1E → VK_A French (AZERTY) layout active: Scancode 0x1E → VK_Q German (QWERTZ) layout active: Scancode 0x1E → VK_A Second: VK-to-Character mapping (with modifiers and dead keys)\nThe same DLL also defines what character (or function) each VK code produces, including potential modifiers (Shift, Ctrl, Alt, AltGr) and dead key combinations. For this example (Scancode Ox1E) we get:\nUS layout DLL: VK_A + no modifiers → 'a' VK_A + Shift → 'A' VK_A + Ctrl → (control code, application-dependent, typically \"mark all\") French AZERTY layout DLL: Scancode 0x1E (US-ANSI A-key physical position): VK_Q + no modifiers = 'q' VK_Q + Shift = 'Q' VK_Q + Ctrl → (control code, application-dependent, typically \"close window\") Understanding the relationship:\nScancodes represent physical positions (hardware-level, unchanging) VK codes represent which key (semantically) is at that position in the active Windows keyboard layout The Windows keyboard layout DLL defines BOTH the scancode-to-VK mapping AND the VK-to-character mapping The entire chain — from scancode to VK to character — is bundled in the DLL for that layout. When you switch Windows keyboard layouts, a completely different DLL takes over, and both mappings change accordingly.\nWhy Virtual Keys Exist: The Design Philosophy You might ask: why not map scancodes directly to characters, or use raw HID usage IDs throughout? Why introduce an intermediate VK layer at all?\nThe answer reveals Windows’s design philosophy: VK codes allow different applications to choose which abstraction level matters for their use case.\nApplications have a fundamental choice:\nOption 1: Use Scancodes (Position-Based, Layout-Independent)\n“I care about physical position, not what character it produces” Examples: Games (Counter-Strike, Valorant), music software (Ableton), stream decks, accessibility tools Method: Use Raw Input API or DirectInput, bypass VK codes entirely Behavior: Work identically across all Windows keyboard layouts because they use the physical position (scancode), not the layout-dependent VK Option 2: Use VK Codes (Layout-Dependent)\n“I care about what key this is in the user’s active Windows keyboard layout” Examples: Text editors, system shortcuts, most productivity software Method: Use the standard Windows message loop (WM_KEYDOWN, WM_KEYUP, WM_CHAR), work with the Windows keyboard layout system Behavior: Automatically adapt to any active Windows keyboard layout This design choice enables two critical capabilities:\n1. Games Work Perfectly Across Windows Keyboard Layouts WASD movement keys work on AZERTY keyboards as ZQSD — automatically. Why?\nGames use raw input or scancode-based input, binding to physical positions:\nGame binding: \"Physical position 0x11 forward\" (using scancode) US QWERTY keyboard: Physical position 0x11 has \"W\" printed on it Player presses W → scancode 0x11 sent → forward movement French AZERTY keyboard: Same physical position 0x11 has \"Z\" printed on it Player presses Z (at position 0x11) → scancode 0x11 sent → forward movement Result: Movement works identically in both cases because both use the same physical position Games never see VK codes; they only see scancodes (physical positions). The physical position is constant, so gameplay is identical regardless of Windows keyboard layout.\n2. One Keyboard, Multiple Windows Keyboard Layouts at Runtime You can switch Windows keyboard layouts in Settings without touching drivers, restarting, or reconfiguring hardware. The same keyboard works with:\nUS English (QWERTY) French (AZERTY) German (QWERTZ) Dvorak Colemak And dozens of others Only the Windows keyboard layout DLL changes; the scancode-to-VK mapping updates accordingly; the hardware communication stays constant.\nWhen Different Applications Use Different Steps Different applications interface with different levels of the keyboard chain, which is why the same key can behave differently in different programs:\nScancode-Based Input: Games and Position-Sensitive Software Games like Counter-Strike, Valorant, and music software like Ableton Live use raw input or scancode-based input via DirectInput or the Raw Input API.\nThese applications:\nReceive hardware scancodes directly, bypassing VK codes and Windows keyboard layouts entirely Work identically on QWERTY, AZERTY, QWERTZ, or any Windows keyboard layout because they use physical positions Allow users to rebind controls to any physical position without layout interference Why: Games optimize for physical control consistency. A player expects WASD to be in the same physical locations regardless of Windows keyboard layout. The physical location is the contract; the character produced is irrelevant.\nVK-Code-Based Input: Some System Hotkeys and Applications Some applications bind system hotkeys using VK codes. However, this is complicated because the same application might use both approaches.\nFor example, in hotkey definition dialogs:\nThe application often records scancodes when you press keys But when processing hotkeys during runtime, it checks VK codes against the active Windows keyboard layout This creates a problematic gap: if you define a hotkey while one Windows keyboard layout is active, and then switch to a different Windows keyboard layout, the hotkey may not work as expected. The scancode you recorded might map to a different VK code on the new layout.\nAdditionally, certain software (like Microsoft PowerToys) cannot record hotkeys when a software remapping layer is active, the likely reason is that the hotkey definition field checks the scancode at definition time, while the running application checks VK codes during execution. A remapping layer that transforms scancodes before they reach the definition dialog will appear to send different keys than the hotkey detection system can record, but once the hotkeys are defined, the remapping layer works transparently during runtime because it operates after VK code generation.\nCharacter-Based Input: Text Fields and IME-Aware Applications Some applications care only about the final output character, not the key code at all:\nRegister for WM_CHAR messages (the final Unicode character after all transformations) Ignore WM_KEYDOWN and WM_KEYUP entirely Work with any input method (keyboard, Input Method Editor, voice-to-text, touch typing) Why: These applications are text-focused and don’t care how the text arrived. Whether the user typed it, pasted it, or used an IME to compose it, the application receives the final Unicode character.\nThe Relationship Between Layers: A Complex Reality The three-layer abstraction (scancode → VK → character) suggests a clean separation, but the reality is more tangled:\nWithin the Windows keyboard layout DLL:\nThe scancode-to-VK mapping is hardcoded for that layout The VK-to-character mapping is also defined (including with modifiers and dead keys) There’s no separation between these steps; they’re bundled in the DLL Across different Windows keyboard layouts:\nThe same physical key (same scancode) produces different VK codes on different layouts The same VK code might not exist on all layouts (e.g., VK_OEM_1 varies) Applications assuming consistent VK codes across layouts will break At the application level:\nHotkey definition and hotkey execution might use different abstractions Some apps record scancodes but check VK codes during execution Software remapping layers can interfere with hotkey recording but not execution. This inconsistency can be a source of confusion for users trying to remap their keyboard with tools like Kanata or Autohotkey. Conclusion Windows keyboard input is layered. Each layer solves specific problems:\nHID usage IDs provide OS-independent hardware communication Scancodes identify raw physical positions (which is why games work across layouts) VK codes enable layout switching at runtime without driver changes Windows keyboard layout DLLs transform VK codes into characters However, the abstraction can lead to unexpected behavior or problems in practice:\nApplications mix abstractions (record scancodes, check VK codes) Software remapping layers can interfere with some use cases but not others The VK-based system works well for text input but creates complexity for system shortcuts and keybindings The current design enables important features (runtime layout switching, game portability) but also creates the “Windows keyboard input hell” that many advanced users experience. More sophisticated features — like timed input methods, such as layers via hold-tap, autoshift, key combinations (combos), or context-aware keybindings are not available within the Windows keyboard layer system. These require either custom firmware (e.g. QMK, ZMK) or software remapping layers (e.g. Kanata, AutoHotkey), which introduce their own complexities and compatibility issues.\nUnderstanding which layer you’re working with, and which abstraction level your application uses, is the first step toward navigating this complexity. To dive even deeper read the follow-up article covering AltGr layers, dead keys, IME and the different options for keyboard remapping.\nReferences [1] Microsoft Learn: Keyboard Input Overview\n[2] A summary of scan code \u0026 key codes sets used in the PC virtualization stack\n[3] Microsoft Learn: ToUnicode function\n[4] Stack Overflow: Detect if Right Alt generates Ctrl+Alt (AltGr) in current layout\n","wordCount":"2019","inLanguage":"en","image":"https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain.png","datePublished":"2026-01-06T00:00:00Z","dateModified":"2026-01-11T18:12:10+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/"},"publisher":{"@type":"Organization","name":"Keyboard Heaven","logo":{"@type":"ImageObject","url":"https://rpnfan.github.io/keyboard-heaven/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rpnfan.github.io/keyboard-heaven/ accesskey=h title="Keyboard Heaven (Alt + H)">Keyboard Heaven</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rpnfan.github.io/keyboard-heaven/ title="Your Path to Keyboard Heaven"><span>Steps</span></a></li><li><a href=https://rpnfan.github.io/keyboard-heaven/deep-dive/ title="Keyboard Analyzers and More"><span>Deep Dive</span></a></li><li><a href=https://rpnfan.github.io/keyboard-heaven/after-party/ title="Still here? Great!"><span>After Party</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Understanding Windows Keyboard Input: The Complete Chain</h1><div class=post-description>Windows keyboard input travels through five transformation layers: HID → Scancode → Virtual Key → Layout → Character. This article explains each layer, why they exist, and why understanding them is crucial when you use or want to create custom keyboard layouts.</div><div class=post-meta><span title='2026-01-06 00:00:00 +0000 UTC'>6 January 2026</span>&nbsp;·&nbsp;<span>10 min</span></div></header><figure class=entry-cover><img loading=eager srcset='https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain_hu_8be1d4e8bda69337.png 360w,https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain_hu_7e3d3f7c5174b01e.png 480w,https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain_hu_a4122f7cded33707.png 720w,https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain_hu_a776e43a230e6a98.png 1080w,https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain.png 1200w' src=https://rpnfan.github.io/keyboard-heaven/deep-dive/windows-keyboard-chain/win-keyboard-chain.png sizes="(min-width: 768px) 720px, 100vw" width=1200 height=385 alt="Windows Keyboard Chain"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#terminology-three-distinct-concepts aria-label="Terminology: Three Distinct Concepts">Terminology: Three Distinct Concepts</a><ul><li><a href=#1-physical-key-layout--position aria-label="1. Physical Key Layout / Position">1. Physical Key Layout / Position</a></li><li><a href=#2-windows-keyboard-layout aria-label="2. Windows Keyboard Layout">2. Windows Keyboard Layout</a></li><li><a href=#3-software-remapping-layer aria-label="3. Software Remapping Layer">3. Software Remapping Layer</a></li></ul></li><li><a href=#the-windows-keyboard-input-chain aria-label="The Windows Keyboard Input Chain">The Windows Keyboard Input Chain</a><ul><li><a href=#step-1-hid-usage-id-the-transport-layer aria-label="Step 1: HID Usage ID (The Transport Layer)">Step 1: HID Usage ID (The Transport Layer)</a></li><li><a href=#step-2-windows-scancode-the-position-identifier aria-label="Step 2: Windows Scancode (The Position Identifier)">Step 2: Windows Scancode (The Position Identifier)</a></li><li><a href=#step-3--4-virtual-key-code-and-windows-keyboard-layout-dll-linked-concepts aria-label="Step 3 & 4: Virtual Key Code and Windows Keyboard Layout DLL (Linked Concepts)">Step 3 & 4: Virtual Key Code and Windows Keyboard Layout DLL (Linked Concepts)</a></li><li><a href=#why-virtual-keys-exist-the-design-philosophy aria-label="Why Virtual Keys Exist: The Design Philosophy">Why Virtual Keys Exist: The Design Philosophy</a><ul><li><a href=#1-games-work-perfectly-across-windows-keyboard-layouts aria-label="1. Games Work Perfectly Across Windows Keyboard Layouts">1. Games Work Perfectly Across Windows Keyboard Layouts</a></li><li><a href=#2-one-keyboard-multiple-windows-keyboard-layouts-at-runtime aria-label="2. One Keyboard, Multiple Windows Keyboard Layouts at Runtime">2. One Keyboard, Multiple Windows Keyboard Layouts at Runtime</a></li></ul></li></ul></li><li><a href=#when-different-applications-use-different-steps aria-label="When Different Applications Use Different Steps">When Different Applications Use Different Steps</a><ul><li><a href=#scancode-based-input-games-and-position-sensitive-software aria-label="Scancode-Based Input: Games and Position-Sensitive Software">Scancode-Based Input: Games and Position-Sensitive Software</a></li><li><a href=#vk-code-based-input-some-system-hotkeys-and-applications aria-label="VK-Code-Based Input: Some System Hotkeys and Applications">VK-Code-Based Input: Some System Hotkeys and Applications</a></li><li><a href=#character-based-input-text-fields-and-ime-aware-applications aria-label="Character-Based Input: Text Fields and IME-Aware Applications">Character-Based Input: Text Fields and IME-Aware Applications</a></li></ul></li><li><a href=#the-relationship-between-layers-a-complex-reality aria-label="The Relationship Between Layers: A Complex Reality">The Relationship Between Layers: A Complex Reality</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>When you press a key on your Windows keyboard, the input doesn&rsquo;t immediately appear on your screen. Instead, it travels through multiple transformation layers — a chain that converts raw hardware signals into text, hotkeys, and game commands. Understanding this chain is essential for anyone working with custom keyboards, keyboard layouts, or applications that handle input.</p><p>The complete Windows keyboard input chain looks like this:</p><pre tabindex=0><code>HID Usage ID → Windows Scancode → Virtual Key Code (VK) → 
Windows Keyboard Layout → Character Output / Application Input
</code></pre><p>But the story is more complex than it appears. Not all applications use every step, and choosing which step to use has profound consequences for compatibility and functionality.</p><h2 id=terminology-three-distinct-concepts>Terminology: Three Distinct Concepts<a hidden class=anchor aria-hidden=true href=#terminology-three-distinct-concepts>#</a></h2><p>Before diving into the chain, it&rsquo;s crucial to clarify three concepts that are often confused because they&rsquo;re all called &ldquo;keyboard layout&rdquo; in casual speech:</p><h3 id=1-physical-key-layout--position>1. Physical Key Layout / Position<a hidden class=anchor aria-hidden=true href=#1-physical-key-layout--position>#</a></h3><p>The physical arrangement of keys on the keyboard hardware.</p><p>Examples: ANSI 104-key (standard US), ISO 105-key (European), split columnar staggered ergonomic keyboards (Kinesis Advantage, Lily58 &mldr;)</p><h3 id=2-windows-keyboard-layout>2. Windows Keyboard Layout<a hidden class=anchor aria-hidden=true href=#2-windows-keyboard-layout>#</a></h3><p>The input layout selected in Windows Settings under Language & Region → Keyboard, determining character mapping and Virtual Key assignments.</p><p>Examples: US English (QWERTY), French (AZERTY), German (QWERTZ), Dvorak, Colemak</p><h3 id=3-software-remapping-layer>3. Software Remapping Layer<a hidden class=anchor aria-hidden=true href=#3-software-remapping-layer>#</a></h3><p>Custom key transformations applied via software tools (such as Kanata, AutoHotkey) that intercept input after the Windows keyboard layout processes it.</p><p>Examples: Kanata profiles (e.g. for <a href=https://github.com/rpnfan/Anymak>anymak:END</a>, Graphite), AutoHotkey scripts</p><p>Note: QMK or ZMK firmware is different — it operates at the HID level, <em>replacing</em> the standard HID input from a keyboard, not layering on top of the Windows keyboard layout.</p><h2 id=the-windows-keyboard-input-chain>The Windows Keyboard Input Chain<a hidden class=anchor aria-hidden=true href=#the-windows-keyboard-input-chain>#</a></h2><figure class=fullwidth><img loading=lazy src=win-keyboard-chain.png alt="Windows Keyboard Chain"></figure><h3 id=step-1-hid-usage-id-the-transport-layer>Step 1: HID Usage ID (The Transport Layer)<a hidden class=anchor aria-hidden=true href=#step-1-hid-usage-id-the-transport-layer>#</a></h3><p>Modern USB keyboards speak the language of <strong>HID (Human Interface Device)</strong> standards defined by the USB Implementers Forum. When you press the &ldquo;A&rdquo; key, your keyboard firmware sends a <strong>HID usage ID</strong> — specifically <code>0x04</code> from the HID Keyboard/Keypad page (usage page 0x07) — over the USB bus.</p><p>This is why keyboard firmware like <strong>QMK uses keycodes like <code>KC_A</code></strong>: these are symbolic names for HID usage IDs. The HID standard is universal across operating systems, making it the common ground between your keyboard hardware and any operating system.</p><p>Each operating system then translates that HID usage according to its own architecture. Windows converts HID to scancodes, macOS has its own mapping, Linux has yet another — but they all start from the same HID usage ID.</p><h3 id=step-2-windows-scancode-the-position-identifier>Step 2: Windows Scancode (The Position Identifier)<a hidden class=anchor aria-hidden=true href=#step-2-windows-scancode-the-position-identifier>#</a></h3><p>The Windows HID driver (<code>kbdhid.sys</code>) receives the HID usage ID and converts it into a <strong>Windows keyboard scancode</strong> — essentially a legacy PS/2-era code that identifies the physical key location on the keyboard. <strong>Scancodes are truly form-factor-independent and Windows-keyboard-layout-independent; they represent raw physical positions.</strong>[1][2]</p><p>For example, on a standard ANSI keyboard:</p><ul><li>HID usage <code>0x04</code> (A key) → Windows scancode <code>0x1E</code></li><li>HID usage <code>0x05</code> (B key) → Windows scancode <code>0x30</code></li></ul><p><strong>Critical point:</strong> Scancode <code>0x1E</code> always refers to the same physical key position on an ANSI keyboard, the one labeled &ldquo;A&rdquo; in the US layout. Regardless of which Windows keyboard layout you activate, scancode <code>0x1E</code> always corresponds to that same physical location.</p><p><strong>Why scancodes do .sexist:</strong> Windows maintains decades of backward compatibility with PS/2 keyboard code. Scancodes provide a stable reference to physical hardware positions that doesn&rsquo;t change when the user switches Windows keyboard layouts.</p><h3 id=step-3--4-virtual-key-code-and-windows-keyboard-layout-dll-linked-concepts>Step 3 & 4: Virtual Key Code and Windows Keyboard Layout DLL (Linked Concepts)<a hidden class=anchor aria-hidden=true href=#step-3--4-virtual-key-code-and-windows-keyboard-layout-dll-linked-concepts>#</a></h3><p>The scancode is then passed to the active <strong>Windows keyboard layout</strong>, which is provided as a DLL file (e.g., <code>kbdus.dll</code> for US, <code>kbdfr.dll</code> or the updated <code>kbdfrna.dll</code> for French). This DLL performs two linked transformations:</p><p><strong>First: Scancode-to-VK mapping</strong></p><p>The DLL maps the scancode to a <strong>Virtual Key (VK) code</strong>. This mapping depends entirely on which Windows keyboard layout is active.</p><pre tabindex=0><code>Same physical key position (scancode 0x1E on ANSI keyboard):

US English (QWERTY) layout active:
  Scancode 0x1E → VK_A

French (AZERTY) layout active:
  Scancode 0x1E → VK_Q

German (QWERTZ) layout active:
  Scancode 0x1E → VK_A
</code></pre><p><strong>Second: VK-to-Character mapping (with modifiers and dead keys)</strong></p><p>The same DLL also defines what character (or function) each VK code produces, including potential modifiers (Shift, Ctrl, Alt, AltGr) and dead key combinations. For this example (Scancode Ox1E) we get:</p><pre tabindex=0><code>US layout DLL:
  VK_A + no modifiers → &#39;a&#39;
  VK_A + Shift → &#39;A&#39;
  VK_A + Ctrl → (control code, application-dependent, typically &#34;mark all&#34;)

French AZERTY layout DLL:
Scancode 0x1E (US-ANSI A-key physical position):
  VK_Q + no modifiers = &#39;q&#39;
  VK_Q + Shift = &#39;Q&#39;
  VK_Q + Ctrl → (control code, application-dependent, typically &#34;close window&#34;)
</code></pre><p><strong>Understanding the relationship:</strong></p><ul><li><strong>Scancodes</strong> represent physical positions (hardware-level, unchanging)</li><li><strong>VK codes</strong> represent which key (semantically) is at that position in the active Windows keyboard layout</li><li><strong>The Windows keyboard layout DLL defines BOTH the scancode-to-VK mapping AND the VK-to-character mapping</strong></li></ul><p>The entire chain — from scancode to VK to character — is bundled in the DLL for that layout. When you switch Windows keyboard layouts, a completely different DLL takes over, and both mappings change accordingly.</p><h3 id=why-virtual-keys-exist-the-design-philosophy>Why Virtual Keys Exist: The Design Philosophy<a hidden class=anchor aria-hidden=true href=#why-virtual-keys-exist-the-design-philosophy>#</a></h3><p>You might ask: why not map scancodes directly to characters, or use raw HID usage IDs throughout? Why introduce an intermediate VK layer at all?</p><p>The answer reveals Windows&rsquo;s design philosophy: <strong>VK codes allow different applications to choose which abstraction level matters for their use case.</strong></p><p>Applications have a fundamental choice:</p><p><strong>Option 1: Use Scancodes (Position-Based, Layout-Independent)</strong></p><ul><li>&ldquo;I care about physical position, not what character it produces&rdquo;</li><li>Examples: Games (Counter-Strike, Valorant), music software (Ableton), stream decks, accessibility tools</li><li>Method: Use Raw Input API or DirectInput, bypass VK codes entirely</li><li>Behavior: Work identically across all Windows keyboard layouts because they use the physical position (scancode), not the layout-dependent VK</li></ul><p><strong>Option 2: Use VK Codes (Layout-Dependent)</strong></p><ul><li>&ldquo;I care about what key this is in the user&rsquo;s active Windows keyboard layout&rdquo;</li><li>Examples: Text editors, system shortcuts, most productivity software</li><li>Method: Use the standard Windows message loop (WM_KEYDOWN, WM_KEYUP, WM_CHAR), work with the Windows keyboard layout system</li><li>Behavior: Automatically adapt to any active Windows keyboard layout</li></ul><p>This design choice enables two critical capabilities:</p><h4 id=1-games-work-perfectly-across-windows-keyboard-layouts>1. Games Work Perfectly Across Windows Keyboard Layouts<a hidden class=anchor aria-hidden=true href=#1-games-work-perfectly-across-windows-keyboard-layouts>#</a></h4><p>WASD movement keys work on AZERTY keyboards as ZQSD — automatically. Why?</p><p>Games use <strong>raw input</strong> or <strong>scancode-based input</strong>, binding to physical positions:</p><pre tabindex=0><code>Game binding: &#34;Physical position 0x11 forward&#34; (using scancode)

US QWERTY keyboard:
  Physical position 0x11 has &#34;W&#34; printed on it
  Player presses W → scancode 0x11 sent → forward movement

French AZERTY keyboard:
  Same physical position 0x11 has &#34;Z&#34; printed on it
  Player presses Z (at position 0x11) → scancode 0x11 sent → forward movement

Result: Movement works identically in both cases because both use the same physical position
</code></pre><p>Games never see VK codes; they only see scancodes (physical positions). The physical position is constant, so gameplay is identical regardless of Windows keyboard layout.</p><h4 id=2-one-keyboard-multiple-windows-keyboard-layouts-at-runtime>2. One Keyboard, Multiple Windows Keyboard Layouts at Runtime<a hidden class=anchor aria-hidden=true href=#2-one-keyboard-multiple-windows-keyboard-layouts-at-runtime>#</a></h4><p>You can switch Windows keyboard layouts in Settings without touching drivers, restarting, or reconfiguring hardware. The same keyboard works with:</p><ul><li>US English (QWERTY)</li><li>French (AZERTY)</li><li>German (QWERTZ)</li><li>Dvorak</li><li>Colemak</li><li>And dozens of others</li></ul><p>Only the Windows keyboard layout DLL changes; the scancode-to-VK mapping updates accordingly; the hardware communication stays constant.</p><h2 id=when-different-applications-use-different-steps>When Different Applications Use Different Steps<a hidden class=anchor aria-hidden=true href=#when-different-applications-use-different-steps>#</a></h2><p>Different applications interface with different levels of the keyboard chain, which is why the same key can behave differently in different programs:</p><h3 id=scancode-based-input-games-and-position-sensitive-software>Scancode-Based Input: Games and Position-Sensitive Software<a hidden class=anchor aria-hidden=true href=#scancode-based-input-games-and-position-sensitive-software>#</a></h3><p>Games like Counter-Strike, Valorant, and music software like Ableton Live use <strong>raw input</strong> or <strong>scancode-based input</strong> via DirectInput or the Raw Input API.</p><p>These applications:</p><ul><li>Receive <strong>hardware scancodes directly</strong>, bypassing VK codes and Windows keyboard layouts entirely</li><li>Work <strong>identically on QWERTY, AZERTY, QWERTZ, or any Windows keyboard layout</strong> because they use physical positions</li><li>Allow users to rebind controls to any physical position without layout interference</li></ul><p><strong>Why:</strong> Games optimize for <strong>physical control consistency</strong>. A player expects WASD to be in the same physical locations regardless of Windows keyboard layout. The physical location is the contract; the character produced is irrelevant.</p><h3 id=vk-code-based-input-some-system-hotkeys-and-applications>VK-Code-Based Input: Some System Hotkeys and Applications<a hidden class=anchor aria-hidden=true href=#vk-code-based-input-some-system-hotkeys-and-applications>#</a></h3><p>Some applications bind system hotkeys using VK codes. However, this is complicated because <strong>the same application might use both approaches</strong>.</p><p>For example, in hotkey definition dialogs:</p><ul><li>The application often records <strong>scancodes</strong> when you press keys</li><li>But when processing hotkeys during runtime, it checks <strong>VK codes</strong> against the active Windows keyboard layout</li></ul><p>This creates a problematic gap: <strong>if you define a hotkey while one Windows keyboard layout is active, and then switch to a different Windows keyboard layout, the hotkey may not work as expected.</strong> The scancode you recorded might map to a different VK code on the new layout.</p><p>Additionally, certain software (like Microsoft PowerToys) <strong>cannot record hotkeys when a software remapping layer is active</strong>, the likely reason is that the hotkey definition field checks the <strong>scancode</strong> at definition time, while the running application checks <strong>VK codes</strong> during execution. A remapping layer that transforms scancodes before they reach the definition dialog will appear to send different keys than the hotkey detection system can record, but once the hotkeys are defined, the remapping layer works transparently during runtime because it operates after VK code generation.</p><h3 id=character-based-input-text-fields-and-ime-aware-applications>Character-Based Input: Text Fields and IME-Aware Applications<a hidden class=anchor aria-hidden=true href=#character-based-input-text-fields-and-ime-aware-applications>#</a></h3><p>Some applications care only about the <strong>final output character</strong>, not the key code at all:</p><ul><li>Register for <strong><code>WM_CHAR</code> messages</strong> (the final Unicode character after all transformations)</li><li>Ignore <code>WM_KEYDOWN</code> and <code>WM_KEYUP</code> entirely</li><li>Work with <strong>any input method</strong> (keyboard, Input Method Editor, voice-to-text, touch typing)</li></ul><p><strong>Why:</strong> These applications are text-focused and don&rsquo;t care how the text arrived. Whether the user typed it, pasted it, or used an IME to compose it, the application receives the final Unicode character.</p><h2 id=the-relationship-between-layers-a-complex-reality>The Relationship Between Layers: A Complex Reality<a hidden class=anchor aria-hidden=true href=#the-relationship-between-layers-a-complex-reality>#</a></h2><p>The three-layer abstraction (scancode → VK → character) suggests a clean separation, but the reality is more tangled:</p><p><strong>Within the Windows keyboard layout DLL:</strong></p><ul><li>The scancode-to-VK mapping is hardcoded for that layout</li><li>The VK-to-character mapping is also defined (including with modifiers and dead keys)</li><li>There&rsquo;s no separation between these steps; they&rsquo;re bundled in the DLL</li></ul><p><strong>Across different Windows keyboard layouts:</strong></p><ul><li>The same physical key (same scancode) produces different VK codes on different layouts</li><li>The same VK code might not exist on all layouts (e.g., VK_OEM_1 varies)</li><li>Applications assuming consistent VK codes across layouts will break</li></ul><p><strong>At the application level:</strong></p><ul><li>Hotkey definition and hotkey execution might use different abstractions<ul><li>Some apps record scancodes but check VK codes during execution</li><li>Software remapping layers can interfere with hotkey recording but not execution. This inconsistency can be a source of confusion for users trying to remap their keyboard with tools like Kanata or Autohotkey.</li></ul></li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Windows keyboard input is layered. Each layer solves specific problems:</p><ul><li><strong>HID usage IDs</strong> provide OS-independent hardware communication</li><li><strong>Scancodes</strong> identify raw physical positions (which is why games work across layouts)</li><li><strong>VK codes</strong> enable layout switching at runtime without driver changes</li><li><strong>Windows keyboard layout DLLs</strong> transform VK codes into characters</li></ul><p>However, the abstraction can lead to unexpected behavior or problems in practice:</p><ul><li>Applications mix abstractions (record scancodes, check VK codes)</li><li>Software remapping layers can interfere with some use cases but not others</li><li>The VK-based system works well for text input but creates complexity for system shortcuts and keybindings</li></ul><p>The current design enables important features (runtime layout switching, game portability) but also creates the &ldquo;Windows keyboard input hell&rdquo; that many advanced users experience. More sophisticated features — like timed input methods, such as layers via hold-tap, autoshift, key combinations (combos), or context-aware keybindings <strong>are not available</strong> within the Windows keyboard layer system. These require either custom firmware (e.g. QMK, ZMK) or software remapping layers (e.g. Kanata, AutoHotkey), which introduce their own complexities and compatibility issues.</p><p>Understanding which layer you&rsquo;re working with, and which abstraction level your application uses, is the first step toward navigating this complexity. To dive even deeper read the <a href=/keyboard-heaven/deep-dive/windows-keyboard-chain-advanced/>follow-up article</a> covering AltGr layers, dead keys, IME and the different options for keyboard remapping.</p><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] <a href=https://learn.microsoft.com/en-us/windows/win32/inputdev/about-keyboard-input>Microsoft Learn: Keyboard Input Overview</a></p><p>[2] <a href=https://www.berrange.com/posts/2010/07/04/a-summary-of-scan-code-key-codes-sets-used-in-the-pc-virtualization-stack/>A summary of scan code & key codes sets used in the PC virtualization stack</a></p><p>[3] <a href=https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-tounicode>Microsoft Learn: ToUnicode function</a></p><p>[4] <a href=https://stackoverflow.com/questions/58633725/windows-detect-if-right-alt-generates-ctrlalt-altgr-in-current-layout>Stack Overflow: Detect if Right Alt generates Ctrl+Alt (AltGr) in current layout</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer><footer class=page-dates>Published: Jan 6, 2026<br>Last modified: Jan 11, 2026</footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer-icons style=text-align:center;margin-top:2em><a href=https://github.com/rpnfan target=_blank rel=noopener style="margin:0 15px"><svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-label="GitHub"><path d="M12 0C5.37.0.0 5.37.0 12c0 5.3 3.44 9.8 8.21 11.39.6.11.82-.26.82-.58v-2.02c-3.34.73-4.04-1.61-4.04-1.61-.55-1.39-1.34-1.76-1.34-1.76-1.09-.74.08-.73.08-.73 1.2.09 1.83 1.23 1.83 1.23 1.07 1.83 2.8 1.3 3.48.99.11-.78.42-1.3.76-1.6-2.67-.3-5.47-1.34-5.47-5.95.0-1.31.47-2.38 1.24-3.22-.12-.3-.54-1.52.12-3.17.0.0 1-.32 3.29 1.23a11.4 11.4.0 016 0c2.29-1.55 3.29-1.23 3.29-1.23.66 1.65.24 2.87.12 3.17.77.84 1.24 1.91 1.24 3.22.0 4.62-2.8 5.65-5.48 5.95.43.37.81 1.1.81 2.22v3.29c0 .32.22.69.82.58A12 12 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
</a><a href=https://www.youtube.com/@keyboards_but_no_kitchen_sink target=_blank rel=noopener style="margin:0 15px"><svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-label="YouTube"><path d="M23.5 6.2a2.9 2.9.0 00-2-2c-2.3-.5-9.5-.5-9.5-.5s-7.2.0-9.5.5a2.9 2.9.0 00-2 2C0 8.5.0 12 0 12s0 3.5.5 5.8a2.9 2.9.0 002 2c2.3.5 9.5.5 9.5.5s7.2.0 9.5-.5a2.9 2.9.0 002-2c.5-2.3.5-5.8.5-5.8s0-3.5-.5-5.8zM9.6 15.6V8.4L16 12l-6.4 3.6z"/></svg></a></div><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);const n=document.querySelector(`[id='${decodeURIComponent(t)}']`);if(!n)return;window.matchMedia("(prefers-reduced-motion: reduce)").matches?n.scrollIntoView():n.scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>const toggle=document.getElementById("theme-toggle");toggle&&toggle.addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>