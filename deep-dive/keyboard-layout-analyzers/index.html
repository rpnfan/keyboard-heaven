<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Keyboard Layout Analyzers Explained: What They Can (and Can't) Do | Keyboard Heaven</title><meta name=keywords content><meta name=description content="Keyboard layout analyzers are powerful tools—but they have significant blind spots. Learn what they can and can't tell you about keyboard optimization, and how to get most out of them."><meta name=author content><link rel=canonical href=https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/><link crossorigin=anonymous href=/keyboard-heaven/assets/css/stylesheet.126ebacd42cca6ed4a15a327717f23082469d45c1055c4f457f3370621504a7f.css integrity="sha256-Em66zULMpu1KFaMncX8jCCRp1FwQVcT0V/M3BiFQSn8=" rel="preload stylesheet" as=style><link rel=icon href=https://rpnfan.github.io/keyboard-heaven/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rpnfan.github.io/keyboard-heaven/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rpnfan.github.io/keyboard-heaven/favicon-32x32.png><link rel=apple-touch-icon href=https://rpnfan.github.io/keyboard-heaven/apple-touch-icon.png><link rel=mask-icon href=https://rpnfan.github.io/keyboard-heaven/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/"><meta property="og:site_name" content="Keyboard Heaven"><meta property="og:title" content="Keyboard Layout Analyzers Explained: What They Can (and Can't) Do"><meta property="og:description" content="Keyboard layout analyzers are powerful tools—but they have significant blind spots. Learn what they can and can't tell you about keyboard optimization, and how to get most out of them."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="deep-dive"><meta property="article:published_time" content="2026-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-11T18:12:10+01:00"><meta property="og:image" content="https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer.png"><meta name=twitter:title content="Keyboard Layout Analyzers Explained: What They Can (and Can't) Do"><meta name=twitter:description content="Keyboard layout analyzers are powerful tools—but they have significant blind spots. Learn what they can and can't tell you about keyboard optimization, and how to get most out of them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Keyboard Analyzers and More","item":"https://rpnfan.github.io/keyboard-heaven/deep-dive/"},{"@type":"ListItem","position":2,"name":"Keyboard Layout Analyzers Explained: What They Can (and Can't) Do","item":"https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Keyboard Layout Analyzers Explained: What They Can (and Can't) Do","name":"Keyboard Layout Analyzers Explained: What They Can (and Can\u0027t) Do","description":"Keyboard layout analyzers are powerful tools—but they have significant blind spots. Learn what they can and can't tell you about keyboard optimization, and how to get most out of them.","keywords":[],"articleBody":"What Layout Analyzers Do Well Layout analyzers are powerful tools. They can save many hours of manual work and help to get a good grasp of a keyboard layout much faster than without. They provide objective data of keyboard layout characteristics, such as bigram distributions, which would take weeks to calculate by hand. Some offer additional visual insights such as showing finger paths, heatmaps of finger use and hand alternation charts. They let you compare dozens of layouts against consistent metrics. They’ve helped discover genuinely useful layouts like AdNW, Enthium, KOY and Graphite.\nBut analyzers have significant limitations. Understanding these limitations is essential before trusting an analyzer’s conclusion that one layout is “better” than another.\nHow analyzers score a layout All analyzers try to score how comfortable or easy certain finger movements are. They either provide numbers for some kind of “effort”, where lower is better. An example is the position on the keyboard or how often the same finger needs to press keys. Often analyzers also provide numbers for metrics which are considered to be good. For example alternating hands between keys or inward rolls on a hand are comfortable and a higher number is better therefore. A general discussion of how to rate a keyboard layout is given in the article about Dvorak’s keyboard design principles.\nThe Three Core Limitations of Layout Analyzers Limitation 1: Not All “Bad Motions” Are Equal, But Analyzers Treat Them As Equal Same-finger bigrams (SFBs) are a good example. An SFB on a strong finger (index or middle finger) from the top row back to the home row (like E-D in QWERTY) is fundamentally different from an SFB on a weak finger (ring finger or pinky) from the home row down to the bottom row (like S-Z in QWERTY).\nWhy the difference? When you press E-D, your finger leaves the home position briefly and returns naturally as part of the next keystroke. The motion still flows. Depending on the key caps you might even be able to “rake” the finger from one key to the other. In contrast S-Z requires your weak finger to stretch down and return to home position – a much more disruptive motion.\nWhat analyzers typically do: Count both as “1 SFB” with equal weight.\nWhat they miss: These motions have different real ergonomic costs. A layout with a moderate amount of higher SFBs might feel better if most of those SFBs are the harmless top-to-home variety.\nReal example: For English anymak:END has a higher SFB percentage than some modern layouts (like Graphite). Graphite has 1.1% SFBs (according to ‘opt’ with standard corpus) while anymak:END has 1.7% SFBs. But most of anymak:END’s SFBs occur between the top row and home row on strong fingers (index/middle), the comfortable type. The raw numbers say Graphite is better than anymak:END in regards to SFBs. That is true by counting each SFB equal. But the true efforts are not described granular enough. So you cannot conclude from the single number alone if or by how much a certain layout will feel better or worse.\nThe same issue applies to scissors (two-finger twisting motions). Q-S in QWERTY is worse than A-W, but most analyzers count all scissors equally. A layout with more scissors might feel better if they’re all low-impact combinations. Some scissors “on paper” might actually feel pretty good in reality. An example would be E-F in QWERTY.\nThe solution analyzers miss: We would need a table rating all possible finger-pair combinations by their actual ergonomic cost. This is doable but would require psychophysical experiments (testing with real typists under controlled conditions) to validate.\nLimitation 2: Metrics Are Combined Without Understanding Their Relative Weight Layout analyzers typically measure multiple metrics: same-finger bigrams, hand alternation, inward rolls, outward rolls, scissors, distance traveled, etc. They often those are combined into a single “effort score.”\nThe problem: We don’t know how much each metric actually contributes to how good a layout feels. Also the next step – how combined finger-motions (bigrams or trigrams) – are interacting is not really understood now.\nExample: Analyzer X weights SFBs at 30%, hand alternation at 25%, scissors at 20%, and other factors at 25%. But who decided on those weights? Did someone test it with real typists? Or was it a guess?\nThe mathematical consequence: Imagine an analyzer says Layout A has 2.3% total effort and Layout B has 2.1% effort. The conclusion seems clear: Layout B is better by 0.2%.\nBut here’s the problem: If the underlying uncertainty in measuring these metrics might be ±3.8%, then the difference of 0.2% is noise, not signal. We’re measuring a door’s width to 0.1mm precision when our tape measure has ±1mm error. The apparent difference is meaningless.\nWhy we don’t know the weights: We would need psychophysical experiments with trained and possibly also untrained typists to determine how much each metric actually matters. Do typists notice a 0.5% reduction in same-finger bigrams? Do they notice a 1% improvement in hand alternation? By how much? These are empirical questions, not mathematical ones.\nThe current situation: Most analyzers use educated guesses for their weights. These guesses might be reasonable, but they’re not validated. Layouts optimized against these guesses might not actually feel better in practice.\nThe practical consequence: When two layouts are numerically close (and we do not know yet what “close” means for a specific analyzer score) do not trust to be better alone by the numbers. Test both by typing real text. The difference in “effort score” can be below measurement uncertainty. What you can do is to compare different layouts in regard to a single metric and get a basic idea how they perform for that single parameter – nothing more and nothing less.\nLimitation 3: Layer Switches Are Completely Ignored but They Are Crucial Layout analyzers examine the character positions of the base layer (where all the letters live). They mostly ignore one of the biggest ergonomic factors: where your modifier and layer-switch keys are placed, and how they’re implemented.\nWhy this matters: In typing:\nShifted characters (capitals, symbols) require a layer key (Shift) Language-specific characters (umlauts in German, accents in French) often require a layer key or dead key One-shot vs held layer keys (tap vs hold) change the ergonomic cost dramatically Auto-Shift, Combos or other timed approaches to switch to layers are not considered Example 1: Shift placement and One-shot vs held modifiers\nIn QWERTY, Right-Shift lives on the pinky at the bottom corner – exactly where your pinky has to stretch quite far and you possibly need to twist your hand uncomfortably. For English, this is annoying already. But for German, where capitalizing words is very common, Shift is in heavy use. The pinky strain adds up even more. On an ANSI-keyboard the Left-Shift key is much easier to reach, by just curling the pinky inward a bit. On some keyboards, with nicely sculpted keycaps, that finger motion can even be a comfortable one. So it is crucial to take the position of the shift-key into account and weigh the efforts accordingly.\nA unique characteristic of anymak:END is moving Shift to easy to reach positions. By populating the /-key (QWERTY) with shift, the problem described above gets resolved. In addition shift is a one-shot key on both hands, which minimizes SFBs with character-keys and the shift-key.\nWhen you hold Shift while typing a capital letter, your hand is in a constrained position. You can’t move your hand naturally while Shift is held. When you use one-shot Shift (tap Shift, and the next keystroke becomes capitalized), your hand is free to move between each keystroke. This is more comfortable and feels faster.\nBoth the more comfortable finger placement and the decrease in SFBs due the one-shot function are real world advantages, but become not visible in many analyzers because they don’t examine layer key placement, nor know if you use one-shot layer switching or not.\nExample 2: Language-specific costs\nFor English, Shift is used occasionally. Optimizing its placement is important but less critical than for other languages.\nFor German, where many words are capitalized, Shift placement becomes an even more important ergonomic factor. A layout optimized for English (by an analyzer) might feel more uncomfortable for a German typist who uses Shift constantly.\nFor Hungarian, with heavy use of diacritics and multiple layer-switch keys, the position of all layer keys becomes crucial. An analyzer ignoring layer (or dead-key) placement will produce a layout that feels awkward in practice.\nThe current gap: Layer-key placement is huge optimization space that most analyzers completely ignore. It’s not a minor issue and has a serious impact on how the layout will feel in everyday use. This is true for English users and even more so for many other languages.\nWhy These Limitations Exist: The Ecosystem Behind Analyzers These described limitations do not exist in isolation. They come on top of other challenges:\nThe Corpus Problem An analyzer needs a text corpus (sample of writing) to analyze. But different corpora produce different “optimal” layouts:\nTyping test corpus (common words, balanced): Produces layouts good for general typing Programming corpus (lots of symbols, brackets, semicolons): Produces layouts that prioritize symbol access German corpus with many capitals: Produces layouts where Shift/layer placement optimization becomes more important Prose corpus: Might de-prioritize symbols and focus on letter frequency The consequence: An optimizer produces a layout that’s optimal for that specific corpus – not necessarily for your actual typing. If you code 50% and write mails and messages 50%, but the analyzer only trained on prose, the result might feel wrong for your use case.\nThe Hardware Variability Problem Analyzers often assume a standard ANSI or ISO keyboard with row-staggered keys. But keyboards vary:\nRow-staggered (standard): Key columns are offset by rows Column-staggered (ergonomic split keyboards): Key columns are aligned vertically. Column-staggered keyboards differ significantly in the amount of stagger. 3x5 vs 4x6 + 2 or 3 or more thumb keys Ergonomic split keyboards often come with a base grid (per side) of 3 or 4 rows and 5 or 6 columns. In addition they offer one, two, three or sometimes even more thumb keys per side. Which of those keys do you use for characters, which for what kind of layer switches? Keycaps, Key Size and Switches How large are the thumb keys? Where are they placed in relation to the hand? Do the keys use MX or Choc or another spacing? Even the keycap shape has an influence which keys are how comfortable and precise to use. Nontraditional keyboards Svalboard and other keyboards – how to map these input methods to an analyzer? Hand size variation: What’s reachable for one person might require stretching for another. The consequence: A layout optimized for one hardware type might feel less natural on another. The “optimal” finger reach differs between hardware designs.\nanymak:END’s solution: It was specifically designed to work on both standard row-staggered keyboards and split columnar-staggered keyboards with moderate pinky stagger. Not using the ANSI B-key position was a necessary hardware-compatibility requirement to maintain the same comfortable fingering on both a standard and a split ergo keyboard. But even in that case the analyzer will not fully reflect the actual efforts, when it is not configured to take into account the exact key positions and the efforts for the hand size of the user in question.\nThe Search Algorithm Problem Analyzers use algorithms (usually simulated annealing or genetic algorithms) to search the space of possible layouts. But this search has limitations:\nLocal optima: The algorithm might find a good layout that’s not the best layout. Imagine a landscape of hills; the algorithm might climb a tall hill and think it’s found the peak, missing the actual highest mountain nearby. Search space is huge: With 47 keys and tens of thousands of possible bigrams, the search space is enormous. Perfect optimization is computationally infeasible. Practical consequence: Optimizer-generated layouts are usually good starting points, but they’re not guaranteed to be globally optimal.\nHow Context Factors Interact: A Practical Example Let’s trace how these factors affect two different layouts:\nGraphite:\nCorpus: Optimized for modern English typing Hardware: Works on standard ANSI keyboards Metrics: Low SFBs (1.1%), excellent hand alternation, good rolls Layer consideration: Standard Shift position Result: Feels good for English typing; less ideal for heavy capital use or multiple languages anymak:END:\nCorpus: Optimized on equal weighting of English, German, and Dutch Hardware: Designed to work identically on both row-staggered and column-staggered keyboards Metrics: More SFBs than Graphite (1.7%), but mostly the harmless top-to-home type; excellent hand alternation but still many inward-rolls; strong-finger prioritization Layer consideration: One-shot layer keys in comfortable position, symmetrical left-right placement, B-key position (QWERTY) on ANSI/ ISO not used for hardware compatibility Result: Comfortable for multi-language typing; Shift-heavy use (German) feels better due to one-shot optimization; works on any keyboard; more SFBs but less finger effort, due avoiding harder to reach keys. The lesson: No analyzer can capture all these factors simultaneously. A layout’s quality depends on how well it matches your corpus, your hardware, your layer use, and your typing patterns.\nHow to Use Analyzers Wisely Given these limitations, here’s how to get genuine value from layout analyzers:\n1. Use Analyzers for Exploration, Not Gospel\nRun an analyzer on a few layout variations. Use the graphical output (finger paths, heatmaps, hand alternation charts) to understand the visual differences.\nDon’t obsess over the raw “effort score.” The finger path charts from opt are an excellent addition to the numbers.\n2. Compare Across Multiple Metrics Separately\nInstead of trusting a combined “effort score,” compare individual metrics:\nHow many SFBs, and where are they? (Top-row-to-bottom-row SFBs are less of a concern.) What’s the hand alternation? (Higher is always better) How many inward rolls? (Higher is better too) How many scissors, and what type? (Pinky scissors are worse than index-finger scissors. It is relevant which finger is up and which one down.) How many redirects – especially on weak fingers? Keep these separate. A layout strong in one area might and often will be weaker in another, but that trade-off might suit your typing better. In the end the search is not for the perfect layout – which can not exist – but for a good balance of different criteria. Some being more important than other. Yet, we do not know the absolute “best weighting” of those for now.\n3. Remember the Corpus Matters\nIf you’re optimizing for programming, use a programming corpus. If you’re optimizing for German writing, use German text with proper capitalization and umlauts. Make the corpus large enough. The manual from the opt analyzer has a section on how to find out if the corpus is large enough.\n4. Factor in Layer-Key Placement Manually\nAnalyzers ignore this often, but you shouldn’t. Ask yourself:\nWhere are my Shift/layer keys? Are they one-shot or held? Or do you use another way to enter layers, such as autoshift or combos? Or do you use home-row-mods for shift? Are they on weak fingers (pinkies) or strong ones (index/middle) or on the thumb? How comfortable are they to reach? If I type heavily in a language with capitals or diacritics, is layer placement optimized for that? This is optimization space the analyzer might be missing. You can and should take that into account in some way.\n5. Test Similar Layouts Practically\nWhen an analyzer shows two layouts as nearly equivalent numerically, don’t try to pick based on small differences in effort score. Instead:\nTry both layouts with a simulator program, where you use the keyboard layout you already can use, to translate the layout in question to Type real text you care about. The most used words in a language are a good start. It is also worth to have a look at some especially “ugly” words to type for the layout in question. You can find hard to type words in the analyzer from Cyanophage. Notice which layout feels more natural for which words and how many. Pick the layout that feels better overall. Your hands know better than the metrics. 6. Use Analyzers to Understand Trade-Offs, Not to Crown a Winner\nWhen you have a shortlist of 2-3 layouts, use the analyzer to understand what each layout prioritizes:\nLayout A optimizes for hand alternation but has more SFBs Layout B minimizes SFBs but uses more same-hand patterns Layout C prioritizes inward rolls at the cost of some distance This understanding helps you predict whether each layout will feel good for your hands and typing patterns. The numerical “winner” might not be the best choice for you.\n7. Consider What Hardware It Was Designed For\nIf it was optimized for one keyboard type, some optimizations might not transfer to your hardware. If possible change the configuration file to reflect your actual physical key arrangement so you get a meaningful evaluation result.\n8. Verify How Metrics Are Weighted\nIf the weights are guesses, the overall effort score is less reliable. Potentially check the weightings – for example of the finger efforts for each key position – and verify and update as needed if those relate to your personal estimation if one key is harder or easier to reach than another.\nAnalyzer Limitations in Practice: Real Examples Example 1: Graphite vs anymak:END An analyzer might show:\nGraphite: Fewer SFBs (1.1%), excellent hand alternation, optimized for English anymak:END: More SFBs (1.7%), similar hand alternation, optimized for 3 languages Raw verdict: Graphite is slightly better for SFBs; they’re roughly equivalent on hand alternation.\nBut what the analyzer misses:\nGraphite’s Shift is standard (pinky on ANSI keyboard); anymak:END’s Shift is optimized for one-shot in comfortable to reach spot Graphite was optimized for English; anymak:END was optimized for equal English-German-Dutch use and works well with French and Spanish anymak:END works on both standard and columnar-staggered keyboards with identical fingering If you type German 40% of the time with frequent capitals, anymak:END’s Shift optimization is a huge practical advantage that raw metrics from many analyzers don’t show The lesson: Analyzer metrics are comparative but not absolute. They show relative trade-offs within a narrow context, not which layout you’ll actually prefer given your actual use.\nExample 2: Enthium (Thumb-Character Layout) Enthium is an unusual layout that puts common characters on thumb keys instead of finger keys.\nWhat an analyzer sees:\nLower distance traveled (thumb keys are accessible) Different SFB/alternation patterns Maybe lower “effort” What the analyzer misses:\nThumb keys require hardware support (split keyboard, thumb cluster) - layout can not be used with a standard keyboard, such as a laptop Learning curve is high (thumb placement is very different from standard finger-based typing) Not all thumbs are equally strong; thumb-heavy use has different ergonomic characteristics than finger-heavy use, some people get problems when using thumb-heavy layouts Raw verdict: Analyzer says Enthium is efficient; in practice, depends entirely on your hardware and willingness to relearn fundamentally.\nThe lesson: Layouts still require human judgment. Analyzers can’t evaluate them fairly in completeness.\nWhat Makes a Good Analyzer? After understanding these limitations, you might wonder: what would a better analyzer look like?\nA more complete analyzer would:\nWeight metrics empirically. Conduct psychophysical experiments with real typists to determine how much each metric actually affects comfort and speed.\nSupport multiple corpora. Let users train on their actual typing patterns, not just generic text.\nAccount for hardware. Allow different optimization for row-staggered vs column-staggered, or even custom reach maps based on hand size.\nInclude modifier placement. Treat Shift, layer-keys, and one-shot vs held as part of the optimization, not afterthoughts.\nEstimate uncertainty. Report not just a score, but the confidence interval around it. “Layout A is better with ±2% uncertainty” is more useful than “Layout A is 0.5% better.”\nProvide trade-off analysis. Show “Layout A wins on hand alternation; Layout B wins on SFBs” instead of combining them into one opaque score.\nCurrent state: No analyzer does all of these. The ‘opt’ analyzer does some of them reasonably well and offers extensive documentation and customization options, but even it has some of the limitations discussed here.\nConclusion: Analyzers Are Guides, Not Oracles Layout analyzers are genuinely valuable tools for exploring the keyboard-layout space. They save massive amounts of time and catch obvious problems (like a layout with tons of same-finger bigrams).\nBut they’re not oracles. They can’t tell you which layout you’ll actually prefer. They can’t account for your specific hardware, your actual typing patterns, your layer-use intensity, or your language needs. They usually do not measure layer-key ergonomics.\nUse them as guides:\nExplore multiple layouts and understand their trade-offs If possible use the finger-motion diagrams from opt in addition to the numbers Test similar layouts by typing, not by comparing scores Remember that analyzer gaps exist, so test practically Then trust your hands. The best layout is the one that feels best when you type it.\n","wordCount":"3463","inLanguage":"en","image":"https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer.png","datePublished":"2026-01-11T00:00:00Z","dateModified":"2026-01-11T18:12:10+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/"},"publisher":{"@type":"Organization","name":"Keyboard Heaven","logo":{"@type":"ImageObject","url":"https://rpnfan.github.io/keyboard-heaven/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rpnfan.github.io/keyboard-heaven/ accesskey=h title="Keyboard Heaven (Alt + H)">Keyboard Heaven</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rpnfan.github.io/keyboard-heaven/ title="Your Path to Keyboard Heaven"><span>Steps</span></a></li><li><a href=https://rpnfan.github.io/keyboard-heaven/deep-dive/ title="Keyboard Analyzers and More"><span>Deep Dive</span></a></li><li><a href=https://rpnfan.github.io/keyboard-heaven/after-party/ title="Still here? Great!"><span>After Party</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Keyboard Layout Analyzers Explained: What They Can (and Can't) Do</h1><div class=post-description>Keyboard layout analyzers are powerful tools—but they have significant blind spots. Learn what they can and can't tell you about keyboard optimization, and how to get most out of them.</div><div class=post-meta><span title='2026-01-11 00:00:00 +0000 UTC'>11 January 2026</span>&nbsp;·&nbsp;<span>17 min</span></div></header><figure class=entry-cover><img loading=eager srcset='https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer_hu_790869e67cba9294.png 360w,https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer_hu_29dabe3ab3a4d44.png 480w,https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer_hu_11846f07c512cb7d.png 720w,https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer_hu_fa77e7c721d646d2.png 1080w,https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer.png 1200w' src=https://rpnfan.github.io/keyboard-heaven/deep-dive/keyboard-layout-analyzers/keyboard-analyzer.png sizes="(min-width: 768px) 720px, 100vw" width=1200 height=335 alt="Keyboard Analyzers"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-layout-analyzers-do-well aria-label="What Layout Analyzers Do Well">What Layout Analyzers Do Well</a></li><li><a href=#how-analyzers-score-a-layout aria-label="How analyzers score a layout">How analyzers score a layout</a></li><li><a href=#the-three-core-limitations-of-layout-analyzers aria-label="The Three Core Limitations of Layout Analyzers">The Three Core Limitations of Layout Analyzers</a><ul><li><a href=#limitation-1-not-all-bad-motions-are-equal-but-analyzers-treat-them-as-equal aria-label="Limitation 1: Not All &ldquo;Bad Motions&rdquo; Are Equal, But Analyzers Treat Them As Equal">Limitation 1: Not All &ldquo;Bad Motions&rdquo; Are Equal, But Analyzers Treat Them As Equal</a></li><li><a href=#limitation-2-metrics-are-combined-without-understanding-their-relative-weight aria-label="Limitation 2: Metrics Are Combined Without Understanding Their Relative Weight">Limitation 2: Metrics Are Combined Without Understanding Their Relative Weight</a></li><li><a href=#limitation-3-layer-switches-are-completely-ignored-but-they-are-crucial aria-label="Limitation 3: Layer Switches Are Completely Ignored but They Are Crucial">Limitation 3: Layer Switches Are Completely Ignored but They Are Crucial</a></li></ul></li><li><a href=#why-these-limitations-exist-the-ecosystem-behind-analyzers aria-label="Why These Limitations Exist: The Ecosystem Behind Analyzers">Why These Limitations Exist: The Ecosystem Behind Analyzers</a><ul><li><a href=#the-corpus-problem aria-label="The Corpus Problem">The Corpus Problem</a></li><li><a href=#the-hardware-variability-problem aria-label="The Hardware Variability Problem">The Hardware Variability Problem</a></li><li><a href=#the-search-algorithm-problem aria-label="The Search Algorithm Problem">The Search Algorithm Problem</a></li></ul></li><li><a href=#how-context-factors-interact-a-practical-example aria-label="How Context Factors Interact: A Practical Example">How Context Factors Interact: A Practical Example</a></li><li><a href=#how-to-use-analyzers-wisely aria-label="How to Use Analyzers Wisely">How to Use Analyzers Wisely</a></li><li><a href=#analyzer-limitations-in-practice-real-examples aria-label="Analyzer Limitations in Practice: Real Examples">Analyzer Limitations in Practice: Real Examples</a><ul><li><a href=#example-1-graphite-vs-anymakend aria-label="Example 1: Graphite vs anymak:END">Example 1: Graphite vs anymak:END</a></li><li><a href=#example-2-enthium-thumb-character-layout aria-label="Example 2: Enthium (Thumb-Character Layout)">Example 2: Enthium (Thumb-Character Layout)</a></li></ul></li><li><a href=#what-makes-a-good-analyzer aria-label="What Makes a Good Analyzer?">What Makes a Good Analyzer?</a></li><li><a href=#conclusion-analyzers-are-guides-not-oracles aria-label="Conclusion: Analyzers Are Guides, Not Oracles">Conclusion: Analyzers Are Guides, Not Oracles</a></li></ul></div></details></div><div class=post-content><h2 id=what-layout-analyzers-do-well>What Layout Analyzers Do Well<a hidden class=anchor aria-hidden=true href=#what-layout-analyzers-do-well>#</a></h2><p>Layout analyzers are powerful tools. They can save many hours of manual work and help to get a good grasp of a keyboard layout much faster than without. They provide objective data of keyboard layout characteristics, such as bigram distributions, which would take weeks to calculate by hand. Some offer additional visual insights such as showing finger paths, heatmaps of finger use and hand alternation charts. They let you compare dozens of layouts against consistent metrics. They&rsquo;ve helped discover genuinely useful layouts like AdNW, Enthium, KOY and Graphite.</p><p><strong>But analyzers have significant limitations.</strong> Understanding these limitations is essential before trusting an analyzer&rsquo;s conclusion that one layout is &ldquo;better&rdquo; than another.</p><h2 id=how-analyzers-score-a-layout>How analyzers score a layout<a hidden class=anchor aria-hidden=true href=#how-analyzers-score-a-layout>#</a></h2><p>All analyzers try to score how comfortable or easy certain finger movements are. They either provide numbers for some kind of &ldquo;effort&rdquo;, where lower is better. An example is the position on the keyboard or how often the same finger needs to press keys. Often analyzers also provide numbers for metrics which are considered to be good. For example alternating hands between keys or inward rolls on a hand are comfortable and a higher number is better therefore. A general discussion of how to rate a keyboard layout is given in the article about Dvorak&rsquo;s keyboard design principles.</p><h2 id=the-three-core-limitations-of-layout-analyzers>The Three Core Limitations of Layout Analyzers<a hidden class=anchor aria-hidden=true href=#the-three-core-limitations-of-layout-analyzers>#</a></h2><h3 id=limitation-1-not-all-bad-motions-are-equal-but-analyzers-treat-them-as-equal>Limitation 1: Not All &ldquo;Bad Motions&rdquo; Are Equal, But Analyzers Treat Them As Equal<a hidden class=anchor aria-hidden=true href=#limitation-1-not-all-bad-motions-are-equal-but-analyzers-treat-them-as-equal>#</a></h3><p>Same-finger bigrams (SFBs) are a good example. An SFB on a strong finger (index or middle finger) from the top row back to the home row (like E-D in QWERTY) is fundamentally different from an SFB on a weak finger (ring finger or pinky) from the home row down to the bottom row (like S-Z in QWERTY).</p><p><strong>Why the difference?</strong> When you press E-D, your finger leaves the home position briefly and returns naturally as part of the next keystroke. The motion still flows. Depending on the key caps you might even be able to &ldquo;rake&rdquo; the finger from one key to the other. In contrast S-Z requires your weak finger to stretch down and return to home position &ndash; a much more disruptive motion.</p><p><strong>What analyzers typically do:</strong> Count both as &ldquo;1 SFB&rdquo; with equal weight.</p><p><strong>What they miss:</strong> These motions have different real ergonomic costs. A layout with a moderate amount of higher SFBs might feel <em>better</em> if most of those SFBs are the harmless top-to-home variety.</p><p><strong>Real example:</strong> For English anymak:END has a higher SFB percentage than some modern layouts (like Graphite). Graphite has 1.1% SFBs (according to &lsquo;opt&rsquo; with standard corpus) while anymak:END has 1.7% SFBs. But most of anymak:END&rsquo;s SFBs occur between the top row and home row on strong fingers (index/middle), the comfortable type. The raw numbers say Graphite is better than anymak:END in regards to SFBs. That is true by counting each SFB equal. But the true efforts are not described granular enough. So you cannot conclude from the single number alone if or by how much a certain layout will feel better or worse.</p><p><strong>The same issue applies to scissors</strong> (two-finger twisting motions). Q-S in QWERTY is worse than A-W, but most analyzers count all scissors equally. A layout with more scissors might feel better if they&rsquo;re all low-impact combinations. Some scissors &ldquo;on paper&rdquo; might actually feel pretty good in reality. An example would be E-F in QWERTY.</p><p><strong>The solution analyzers miss:</strong> We would need a table rating all possible finger-pair combinations by their actual ergonomic cost. This is doable but would require psychophysical experiments (testing with real typists under controlled conditions) to validate.</p><h3 id=limitation-2-metrics-are-combined-without-understanding-their-relative-weight>Limitation 2: Metrics Are Combined Without Understanding Their Relative Weight<a hidden class=anchor aria-hidden=true href=#limitation-2-metrics-are-combined-without-understanding-their-relative-weight>#</a></h3><p>Layout analyzers typically measure multiple metrics: same-finger bigrams, hand alternation, inward rolls, outward rolls, scissors, distance traveled, etc. They often those are combined into a single &ldquo;effort score.&rdquo;</p><p><strong>The problem:</strong> We don&rsquo;t know how much each metric actually contributes to how good a layout feels. Also the next step &ndash; how combined finger-motions (bigrams or trigrams) &ndash; are interacting is not really understood now.</p><p><strong>Example:</strong> Analyzer X weights SFBs at 30%, hand alternation at 25%, scissors at 20%, and other factors at 25%. But who decided on those weights? Did someone test it with real typists? Or was it a guess?</p><p><strong>The mathematical consequence:</strong> Imagine an analyzer says Layout A has 2.3% total effort and Layout B has 2.1% effort. The conclusion seems clear: Layout B is better by 0.2%.</p><p><strong>But here&rsquo;s the problem:</strong> If the underlying uncertainty in measuring these metrics might be ±3.8%, then the difference of 0.2% is <strong>noise, not signal.</strong> We&rsquo;re measuring a door&rsquo;s width to 0.1mm precision when our tape measure has ±1mm error. The apparent difference is meaningless.</p><p><strong>Why we don&rsquo;t know the weights:</strong> We would need psychophysical experiments with trained and possibly also untrained typists to determine how much each metric actually matters. Do typists notice a 0.5% reduction in same-finger bigrams? Do they notice a 1% improvement in hand alternation? By how much? These are empirical questions, not mathematical ones.</p><p><strong>The current situation:</strong> Most analyzers use educated guesses for their weights. These guesses might be reasonable, but they&rsquo;re not validated. Layouts optimized against these guesses might not actually feel better in practice.</p><p><strong>The practical consequence:</strong> When two layouts are numerically close (and we do not know yet what &ldquo;close&rdquo; means for a specific analyzer score) do not trust to be better alone by the numbers. Test both by typing real text. The difference in &ldquo;effort score&rdquo; can be below measurement uncertainty. What you can do is to compare different layouts in regard to a single metric and get a basic idea how they perform for that single parameter &ndash; nothing more and nothing less.</p><h3 id=limitation-3-layer-switches-are-completely-ignored-but-they-are-crucial>Limitation 3: Layer Switches Are Completely Ignored but They Are Crucial<a hidden class=anchor aria-hidden=true href=#limitation-3-layer-switches-are-completely-ignored-but-they-are-crucial>#</a></h3><p>Layout analyzers examine the character positions of the base layer (where all the letters live). They mostly ignore one of the biggest ergonomic factors: <strong>where your modifier and layer-switch keys are placed, and how they&rsquo;re implemented.</strong></p><p><strong>Why this matters:</strong> In typing:</p><ul><li><strong>Shifted characters</strong> (capitals, symbols) require a layer key (Shift)</li><li><strong>Language-specific characters</strong> (umlauts in German, accents in French) often require a layer key or dead key</li><li><strong>One-shot vs held</strong> layer keys (tap vs hold) change the ergonomic cost dramatically</li><li><strong>Auto-Shift, Combos</strong> or other timed approaches to switch to layers are not considered</li></ul><p><strong>Example 1: Shift placement and One-shot vs held modifiers</strong></p><p>In QWERTY, Right-Shift lives on the pinky at the bottom corner &ndash; exactly where your pinky has to stretch quite far and you possibly need to twist your hand uncomfortably. For English, this is annoying already. But for German, where capitalizing words is very common, Shift is in heavy use. The pinky strain adds up even more. On an ANSI-keyboard the Left-Shift key is much easier to reach, by just curling the pinky inward a bit. On some keyboards, with nicely sculpted keycaps, that finger motion can even be a comfortable one. So it is crucial to take the position of the shift-key into account and weigh the efforts accordingly.</p><p>A unique characteristic of <strong>anymak:END is moving Shift to easy to reach positions</strong>. By populating the /-key (QWERTY) with shift, the problem described above gets resolved. In addition shift is a one-shot key on both hands, which minimizes SFBs with character-keys and the shift-key.</p><p>When you hold Shift while typing a capital letter, your hand is in a constrained position. You can&rsquo;t move your hand naturally while Shift is held. When you use one-shot Shift (tap Shift, and the next keystroke becomes capitalized), your hand is free to move between each keystroke. This is more comfortable and feels faster.</p><p>Both the more comfortable finger placement and the decrease in SFBs due the one-shot function are real world advantages, but become not visible in many analyzers because they don&rsquo;t examine layer key placement, nor know if you use one-shot layer switching or not.</p><p><strong>Example 2: Language-specific costs</strong></p><p>For <strong>English</strong>, Shift is used occasionally. Optimizing its placement is important but less critical than for other languages.</p><p>For <strong>German</strong>, where many words are capitalized, Shift placement becomes an even more important ergonomic factor. A layout optimized for English (by an analyzer) might feel more uncomfortable for a German typist who uses Shift constantly.</p><p>For <strong>Hungarian</strong>, with heavy use of diacritics and multiple layer-switch keys, the position of <em>all</em> layer keys becomes crucial. An analyzer ignoring layer (or dead-key) placement will produce a layout that feels awkward in practice.</p><p><strong>The current gap:</strong> Layer-key placement is huge optimization space that most analyzers completely ignore. It&rsquo;s not a minor issue and has a serious impact on how the layout will feel in everyday use. This is true for English users and even more so for many other languages.</p><h2 id=why-these-limitations-exist-the-ecosystem-behind-analyzers>Why These Limitations Exist: The Ecosystem Behind Analyzers<a hidden class=anchor aria-hidden=true href=#why-these-limitations-exist-the-ecosystem-behind-analyzers>#</a></h2><p>These described limitations do not exist in isolation. They come on top of other challenges:</p><h3 id=the-corpus-problem>The Corpus Problem<a hidden class=anchor aria-hidden=true href=#the-corpus-problem>#</a></h3><p>An analyzer needs a text corpus (sample of writing) to analyze. But different corpora produce different &ldquo;optimal&rdquo; layouts:</p><ul><li><strong>Typing test corpus</strong> (common words, balanced): Produces layouts good for general typing</li><li><strong>Programming corpus</strong> (lots of symbols, brackets, semicolons): Produces layouts that prioritize symbol access</li><li><strong>German corpus with many capitals</strong>: Produces layouts where Shift/layer placement optimization becomes more important</li><li><strong>Prose corpus</strong>: Might de-prioritize symbols and focus on letter frequency</li></ul><p><strong>The consequence:</strong> An optimizer produces a layout that&rsquo;s optimal for that specific corpus &ndash; not necessarily for your actual typing. If you code 50% and write mails and messages 50%, but the analyzer only trained on prose, the result might feel wrong for your use case.</p><h3 id=the-hardware-variability-problem>The Hardware Variability Problem<a hidden class=anchor aria-hidden=true href=#the-hardware-variability-problem>#</a></h3><p>Analyzers often assume a standard ANSI or ISO keyboard with row-staggered keys. But keyboards vary:</p><ul><li><strong>Row-staggered</strong> (standard): Key columns are offset by rows</li><li><strong>Column-staggered</strong> (ergonomic split keyboards): Key columns are aligned vertically. Column-staggered keyboards differ significantly in the amount of stagger.</li><li><strong>3x5 vs 4x6 + 2 or 3 or more thumb keys</strong> Ergonomic split keyboards often come with a base grid (per side) of 3 or 4 rows and 5 or 6 columns. In addition they offer one, two, three or sometimes even more thumb keys per side. Which of those keys do you use for characters, which for what kind of layer switches?</li><li><strong>Keycaps, Key Size and Switches</strong> How large are the thumb keys? Where are they placed in relation to the hand? Do the keys use MX or Choc or another spacing? Even the keycap shape has an influence which keys are how comfortable and precise to use.</li><li><strong>Nontraditional keyboards</strong> Svalboard and other keyboards &ndash; how to map these input methods to an analyzer?</li><li><strong>Hand size variation</strong>: What&rsquo;s reachable for one person might require stretching for another.</li></ul><p><strong>The consequence:</strong> A layout optimized for one hardware type might feel less natural on another. The &ldquo;optimal&rdquo; finger reach differs between hardware designs.</p><p><strong>anymak:END&rsquo;s solution:</strong> It was specifically designed to work on both standard row-staggered keyboards and split columnar-staggered keyboards with moderate pinky stagger. Not using the ANSI B-key position was a necessary hardware-compatibility requirement to maintain the same comfortable fingering on both a standard and a split ergo keyboard. But even in that case the analyzer will not fully reflect the actual efforts, when it is not configured to take into account the exact key positions and the efforts for the hand size of the user in question.</p><h3 id=the-search-algorithm-problem>The Search Algorithm Problem<a hidden class=anchor aria-hidden=true href=#the-search-algorithm-problem>#</a></h3><p>Analyzers use algorithms (usually simulated annealing or genetic algorithms) to search the space of possible layouts. But this search has limitations:</p><ul><li><strong>Local optima:</strong> The algorithm might find a good layout that&rsquo;s not the <em>best</em> layout. Imagine a landscape of hills; the algorithm might climb a tall hill and think it&rsquo;s found the peak, missing the actual highest mountain nearby.</li><li><strong>Search space is huge:</strong> With 47 keys and tens of thousands of possible bigrams, the search space is enormous. Perfect optimization is computationally infeasible.</li></ul><p><strong>Practical consequence:</strong> Optimizer-generated layouts are usually good starting points, but they&rsquo;re not guaranteed to be globally optimal.</p><h2 id=how-context-factors-interact-a-practical-example>How Context Factors Interact: A Practical Example<a hidden class=anchor aria-hidden=true href=#how-context-factors-interact-a-practical-example>#</a></h2><p>Let&rsquo;s trace how these factors affect two different layouts:</p><p><strong>Graphite:</strong></p><ul><li><strong>Corpus:</strong> Optimized for modern English typing</li><li><strong>Hardware:</strong> Works on standard ANSI keyboards</li><li><strong>Metrics:</strong> Low SFBs (1.1%), excellent hand alternation, good rolls</li><li><strong>Layer consideration:</strong> Standard Shift position</li><li><strong>Result:</strong> Feels good for English typing; less ideal for heavy capital use or multiple languages</li></ul><p><strong>anymak:END:</strong></p><ul><li><strong>Corpus:</strong> Optimized on equal weighting of English, German, and Dutch</li><li><strong>Hardware:</strong> Designed to work identically on both row-staggered and column-staggered keyboards</li><li><strong>Metrics:</strong> More SFBs than Graphite (1.7%), but mostly the harmless top-to-home type; excellent hand alternation but still many inward-rolls; strong-finger prioritization</li><li><strong>Layer consideration:</strong> One-shot layer keys in comfortable position, symmetrical left-right placement, B-key position (QWERTY) on ANSI/ ISO not used for hardware compatibility</li><li><strong>Result:</strong> Comfortable for multi-language typing; Shift-heavy use (German) feels better due to one-shot optimization; works on any keyboard; more SFBs but less finger effort, due avoiding harder to reach keys.</li></ul><p><strong>The lesson:</strong> No analyzer can capture all these factors simultaneously. A layout&rsquo;s quality depends on how well it matches <em>your</em> corpus, <em>your</em> hardware, <em>your</em> layer use, and <em>your</em> typing patterns.</p><h2 id=how-to-use-analyzers-wisely>How to Use Analyzers Wisely<a hidden class=anchor aria-hidden=true href=#how-to-use-analyzers-wisely>#</a></h2><p>Given these limitations, here&rsquo;s how to get genuine value from layout analyzers:</p><p><strong>1. Use Analyzers for Exploration, Not Gospel</strong></p><p>Run an analyzer on a few layout variations. Use the <strong>graphical output</strong> (finger paths, heatmaps, hand alternation charts) to understand the visual differences.</p><p>Don&rsquo;t obsess over the raw &ldquo;effort score.&rdquo; The finger path charts from opt are an excellent addition to the numbers.</p><p><strong>2. Compare Across Multiple Metrics Separately</strong></p><p>Instead of trusting a combined &ldquo;effort score,&rdquo; compare individual metrics:</p><ul><li>How many SFBs, and where are they? (Top-row-to-bottom-row SFBs are less of a concern.)</li><li>What&rsquo;s the hand alternation? (Higher is always better)</li><li>How many inward rolls? (Higher is better too)</li><li>How many scissors, and what type? (Pinky scissors are worse than index-finger scissors. It is relevant which finger is up and which one down.)</li><li>How many redirects &ndash; especially on weak fingers?</li></ul><p>Keep these separate. A layout strong in one area might and often will be weaker in another, but that trade-off might suit your typing better. In the end the search is not for the perfect layout &ndash; which can not exist &ndash; but for a good balance of different criteria. Some being more important than other. Yet, we do not know the absolute &ldquo;best weighting&rdquo; of those for now.</p><p><strong>3. Remember the Corpus Matters</strong></p><p>If you&rsquo;re optimizing for programming, use a programming corpus. If you&rsquo;re optimizing for German writing, use German text with proper capitalization and umlauts. Make the corpus large enough. The manual from the opt analyzer has a section on how to find out if the corpus is large enough.</p><p><strong>4. Factor in Layer-Key Placement Manually</strong></p><p>Analyzers ignore this often, but you shouldn&rsquo;t. Ask yourself:</p><ul><li>Where are my Shift/layer keys?</li><li>Are they one-shot or held? Or do you use another way to enter layers, such as autoshift or combos? Or do you use home-row-mods for shift?</li><li>Are they on weak fingers (pinkies) or strong ones (index/middle) or on the thumb? How comfortable are they to reach?</li><li>If I type heavily in a language with capitals or diacritics, is layer placement optimized for that?</li></ul><p>This is optimization space the analyzer might be missing. You can and should take that into account in some way.</p><p><strong>5. Test Similar Layouts Practically</strong></p><p>When an analyzer shows two layouts as nearly equivalent numerically, don&rsquo;t try to pick based on small differences in effort score. Instead:</p><ul><li>Try both layouts with a simulator program, where you use the keyboard layout you already can use, to translate the layout in question to</li><li>Type real text you care about. The most used words in a language are a good start. It is also worth to have a look at some especially &ldquo;ugly&rdquo; words to type for the layout in question. You can find hard to type words in the analyzer from Cyanophage.</li><li>Notice which layout feels more natural for which words and how many. Pick the layout that feels better overall. Your hands know better than the metrics.</li></ul><p><strong>6. Use Analyzers to Understand Trade-Offs, Not to Crown a Winner</strong></p><p>When you have a shortlist of 2-3 layouts, use the analyzer to understand what each layout prioritizes:</p><ul><li>Layout A optimizes for hand alternation but has more SFBs</li><li>Layout B minimizes SFBs but uses more same-hand patterns</li><li>Layout C prioritizes inward rolls at the cost of some distance</li></ul><p>This understanding helps you predict whether each layout will feel good <em>for your hands and typing patterns</em>. The numerical &ldquo;winner&rdquo; might not be the best choice for you.</p><p><strong>7. Consider What Hardware It Was Designed For</strong></p><p>If it was optimized for one keyboard type, some optimizations might not transfer to your hardware. If possible change the configuration file to reflect your actual physical key arrangement so you get a meaningful evaluation result.</p><p><strong>8. Verify How Metrics Are Weighted</strong></p><p>If the weights are guesses, the overall effort score is less reliable. Potentially check the weightings &ndash; for example of the finger efforts for each key position &ndash; and verify and update as needed if those relate to your personal estimation if one key is harder or easier to reach than another.</p><h2 id=analyzer-limitations-in-practice-real-examples>Analyzer Limitations in Practice: Real Examples<a hidden class=anchor aria-hidden=true href=#analyzer-limitations-in-practice-real-examples>#</a></h2><h3 id=example-1-graphite-vs-anymakend>Example 1: Graphite vs anymak:END<a hidden class=anchor aria-hidden=true href=#example-1-graphite-vs-anymakend>#</a></h3><p>An analyzer might show:</p><ul><li>Graphite: Fewer SFBs (1.1%), excellent hand alternation, optimized for English</li><li>anymak:END: More SFBs (1.7%), similar hand alternation, optimized for 3 languages</li></ul><p><strong>Raw verdict:</strong> Graphite is slightly better for SFBs; they&rsquo;re roughly equivalent on hand alternation.</p><p><strong>But what the analyzer misses:</strong></p><ul><li>Graphite&rsquo;s Shift is standard (pinky on ANSI keyboard); anymak:END&rsquo;s Shift is optimized for one-shot in comfortable to reach spot</li><li>Graphite was optimized for English; anymak:END was optimized for equal English-German-Dutch use and works well with French and Spanish</li><li>anymak:END works on both standard and columnar-staggered keyboards with identical fingering</li><li>If you type German 40% of the time with frequent capitals, anymak:END&rsquo;s Shift optimization is a huge practical advantage that raw metrics from many analyzers don&rsquo;t show</li></ul><p><strong>The lesson:</strong> Analyzer metrics are comparative but not absolute. They show relative trade-offs within a narrow context, not which layout you&rsquo;ll actually prefer given your actual use.</p><h3 id=example-2-enthium-thumb-character-layout>Example 2: Enthium (Thumb-Character Layout)<a hidden class=anchor aria-hidden=true href=#example-2-enthium-thumb-character-layout>#</a></h3><p>Enthium is an unusual layout that puts common characters on thumb keys instead of finger keys.</p><p><strong>What an analyzer sees:</strong></p><ul><li>Lower distance traveled (thumb keys are accessible)</li><li>Different SFB/alternation patterns</li><li>Maybe lower &ldquo;effort&rdquo;</li></ul><p><strong>What the analyzer misses:</strong></p><ul><li>Thumb keys require hardware support (split keyboard, thumb cluster) - layout can not be used with a standard keyboard, such as a laptop</li><li>Learning curve is high (thumb placement is very different from standard finger-based typing)</li><li>Not all thumbs are equally strong; thumb-heavy use has different ergonomic characteristics than finger-heavy use, some people get problems when using thumb-heavy layouts</li></ul><p><strong>Raw verdict:</strong> Analyzer says Enthium is efficient; in practice, depends entirely on your hardware and willingness to relearn fundamentally.</p><p><strong>The lesson:</strong> Layouts still require human judgment. Analyzers can&rsquo;t evaluate them fairly in completeness.</p><h2 id=what-makes-a-good-analyzer>What Makes a Good Analyzer?<a hidden class=anchor aria-hidden=true href=#what-makes-a-good-analyzer>#</a></h2><p>After understanding these limitations, you might wonder: what would a better analyzer look like?</p><p><strong>A more complete analyzer would:</strong></p><ol><li><p><strong>Weight metrics empirically.</strong> Conduct psychophysical experiments with real typists to determine how much each metric actually affects comfort and speed.</p></li><li><p><strong>Support multiple corpora.</strong> Let users train on their actual typing patterns, not just generic text.</p></li><li><p><strong>Account for hardware.</strong> Allow different optimization for row-staggered vs column-staggered, or even custom reach maps based on hand size.</p></li><li><p><strong>Include modifier placement.</strong> Treat Shift, layer-keys, and one-shot vs held as part of the optimization, not afterthoughts.</p></li><li><p><strong>Estimate uncertainty.</strong> Report not just a score, but the confidence interval around it. &ldquo;Layout A is better with ±2% uncertainty&rdquo; is more useful than &ldquo;Layout A is 0.5% better.&rdquo;</p></li><li><p><strong>Provide trade-off analysis.</strong> Show &ldquo;Layout A wins on hand alternation; Layout B wins on SFBs&rdquo; instead of combining them into one opaque score.</p></li></ol><p><strong>Current state:</strong> No analyzer does all of these. The &lsquo;opt&rsquo; analyzer does some of them reasonably well and offers extensive documentation and customization options, but even it has some of the limitations discussed here.</p><h2 id=conclusion-analyzers-are-guides-not-oracles>Conclusion: Analyzers Are Guides, Not Oracles<a hidden class=anchor aria-hidden=true href=#conclusion-analyzers-are-guides-not-oracles>#</a></h2><p>Layout analyzers are genuinely valuable tools for exploring the keyboard-layout space. They save massive amounts of time and catch obvious problems (like a layout with tons of same-finger bigrams).</p><p><strong>But they&rsquo;re not oracles.</strong> They can&rsquo;t tell you which layout you&rsquo;ll actually prefer. They can&rsquo;t account for your specific hardware, your actual typing patterns, your layer-use intensity, or your language needs. They usually do not measure layer-key ergonomics.</p><p><strong>Use them as guides:</strong></p><ul><li>Explore multiple layouts and understand their trade-offs</li><li>If possible use the finger-motion diagrams from opt in addition to the numbers</li><li>Test similar layouts by typing, not by comparing scores</li><li>Remember that analyzer gaps exist, so test practically</li></ul><p><strong>Then trust your hands.</strong> The best layout is the one that feels best when you type it.</p></div><footer class=post-footer><ul class=post-tags></ul></footer><footer class=page-dates>Published: Jan 11, 2026<br>Last modified: Jan 11, 2026</footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer-icons style=text-align:center;margin-top:2em><a href=https://github.com/rpnfan target=_blank rel=noopener style="margin:0 15px"><svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-label="GitHub"><path d="M12 0C5.37.0.0 5.37.0 12c0 5.3 3.44 9.8 8.21 11.39.6.11.82-.26.82-.58v-2.02c-3.34.73-4.04-1.61-4.04-1.61-.55-1.39-1.34-1.76-1.34-1.76-1.09-.74.08-.73.08-.73 1.2.09 1.83 1.23 1.83 1.23 1.07 1.83 2.8 1.3 3.48.99.11-.78.42-1.3.76-1.6-2.67-.3-5.47-1.34-5.47-5.95.0-1.31.47-2.38 1.24-3.22-.12-.3-.54-1.52.12-3.17.0.0 1-.32 3.29 1.23a11.4 11.4.0 016 0c2.29-1.55 3.29-1.23 3.29-1.23.66 1.65.24 2.87.12 3.17.77.84 1.24 1.91 1.24 3.22.0 4.62-2.8 5.65-5.48 5.95.43.37.81 1.1.81 2.22v3.29c0 .32.22.69.82.58A12 12 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
</a><a href=https://www.youtube.com/@keyboards_but_no_kitchen_sink target=_blank rel=noopener style="margin:0 15px"><svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor" aria-label="YouTube"><path d="M23.5 6.2a2.9 2.9.0 00-2-2c-2.3-.5-9.5-.5-9.5-.5s-7.2.0-9.5.5a2.9 2.9.0 00-2 2C0 8.5.0 12 0 12s0 3.5.5 5.8a2.9 2.9.0 002 2c2.3.5 9.5.5 9.5.5s7.2.0 9.5-.5a2.9 2.9.0 002-2c.5-2.3.5-5.8.5-5.8s0-3.5-.5-5.8zM9.6 15.6V8.4L16 12l-6.4 3.6z"/></svg></a></div><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);const n=document.querySelector(`[id='${decodeURIComponent(t)}']`);if(!n)return;window.matchMedia("(prefers-reduced-motion: reduce)").matches?n.scrollIntoView():n.scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>const toggle=document.getElementById("theme-toggle");toggle&&toggle.addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>